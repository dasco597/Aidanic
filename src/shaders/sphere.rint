#version 460
#extension GL_NV_ray_tracing : require

// also defined in Renderer.h
#define SPHERE_COUNT_PER_TLAS 8

#define MAX_MARCHING_STEPS 100
#define EPSILON 0.0001
#define MAX_DISTANCE 100.0

struct Sphere {
	vec4 pos_radius;
	vec4 color;
};
layout(set = 1, binding = 1, std430) readonly buffer Spheres { Sphere spheres[SPHERE_COUNT_PER_TLAS]; };

struct Hit_Payload {
	vec4 intersection;
	vec4 color;
	vec4 normal;
};
hitAttributeNV Hit_Payload hit_payload;

float sdf_sphere(vec3 point, vec3 center, float radius) {
	return length(point - center) - radius;
}

void main()
{
	if (gl_InstanceID >= SPHERE_COUNT_PER_TLAS) return;
	
    vec3 ray_o = gl_WorldRayOriginNV;
    vec3 ray_d = normalize(gl_WorldRayDirectionNV);

    vec3 center = spheres[gl_InstanceID].pos_radius.xyz;
    float radius = spheres[gl_InstanceID].pos_radius.w;
	
	float depth = 0.0;
	for (int i = 0; i < MAX_MARCHING_STEPS; i++) {
		vec3 point = ray_o + ray_d * depth;
		float dist = sdf_sphere(point, center, radius);

		if (dist < EPSILON) {
			hit_payload.intersection = vec4(point, 1.0);
			hit_payload.normal = vec4(point - center, 1.0);
			hit_payload.color = spheres[gl_InstanceID].color;
			reportIntersectionNV(depth, 0u);
			return;
		}

		depth += dist;
		if (dist >= MAX_DISTANCE) {
			break;
		}
	}
}