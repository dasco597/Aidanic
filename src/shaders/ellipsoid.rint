#version 460
#extension GL_NV_ray_tracing : require

// also defined in Renderer.h
#define ELLIPSOID_COUNT_PER_TLAS 8

#define MAX_MARCHING_STEPS 100
#define EPSILON 0.0001
#define MAX_DISTANCE 100.0

struct Ellipsoid {
	vec4 pos;
	vec4 radius;
	vec4 color;
};
layout(set = 1, binding = 1, std430) readonly buffer Ellipsoids { Ellipsoid ellipsoids[ELLIPSOID_COUNT_PER_TLAS]; };

struct Hit_Payload {
	vec4 color;
	vec4 normal;
};
hitAttributeNV Hit_Payload hit_payload;

float sdf_ellipsoid(vec3 point, vec3 center, vec3 radius)
{
	float k0 = length(point / radius);
    float k1 = length(point / (radius*radius));
    return k0*(k0-1.0)/k1;
}

vec3 calc_normal(vec3 point, vec3 center, vec3 radius)
{
    vec2 e = vec2(0.0005,0.0);
    return normalize( vec3( 
        sdf_ellipsoid(point + e.xyy, center, radius) - sdf_ellipsoid(point - e.xyy, center, radius),
		sdf_ellipsoid(point + e.yxy, center, radius) - sdf_ellipsoid(point - e.yxy, center, radius),
		sdf_ellipsoid(point + e.yyx, center, radius) - sdf_ellipsoid(point - e.yyx, center, radius) ) );
}

void main()
{
	if (gl_InstanceID >= ELLIPSOID_COUNT_PER_TLAS) return;
	
    vec3 ray_o = gl_WorldRayOriginNV;
    vec3 ray_d = normalize(gl_WorldRayDirectionNV); // todo need to normalize?

    vec3 center = ellipsoids[gl_InstanceID].pos.xyz;
    vec3 radius = ellipsoids[gl_InstanceID].radius.xyz;
	
	float depth = 0.0;
	for (int i = 0; i < MAX_MARCHING_STEPS; i++) {
		vec3 point = ray_o + ray_d * depth;
		float dist = sdf_ellipsoid(point, center, radius);

		if (dist < EPSILON) {
			hit_payload.normal = vec4(calc_normal(point, center, radius), 0.0);
			hit_payload.color = ellipsoids[gl_InstanceID].color;
			reportIntersectionNV(depth, 0u);
			return;
		}

		depth += dist;
		if (dist >= MAX_DISTANCE) {
			break;
		}
	}
}